---
layout: post
title: How to use ES8’s Async (and Await) to write concise promise-returning functions
date: '2017-08-02T08:56:56-07:00'
tags:
- node.js
- javascript
- programming
- frombrett
- es6
- es8
- es2017
- asynchronous
- web development
tumblr_url: http://beekley.xyz/post/163718396481/how-to-use-es8s-async-and-await-to-write
---
<figure class="tmblr-full" data-orig-height="418" data-orig-width="800"><img src="https://78.media.tumblr.com/435c662557b82cd6e7881de2fb5127b8/tumblr_inline_ou2eymuOYg1qb9570_540.png" data-orig-height="418" data-orig-width="800"/></figure><p>It’s no secret (nor surprise) that <code>async</code>/<code>await</code> is one of the most anticipated features of ES8/ES2017. While there are lot of great resources already about the magic of the <code>await</code> keyword, its unsung sidekick <code>async</code> hasn’t gotten the same attention.</p><p>If you’ve used <code>async</code>/<code>await</code> before, you know that <code>async</code> is what allows <code>await</code> to work and is required in the nearest-parent function declaration of any use of the <code>await</code> keyword. Without <code>async</code>, <code>await</code> would just block code execution. That would negate JS’s asynchronous nature, one of JS’s best features and the reason JS can be used server-side (e.g. in Node). In order to do this, <code>async</code> makes the function, well, asynchronous by making the function return a promise, allowing other code to continue running while it <code>await</code>s.</p><p>The side-effect of this is that <code>async</code> makes writing promised-based asynchronous functions both simple and synchronous-like:</p><ol><li>The promise returned by an <code>async</code> function resolves using <code>.then() </code>— just like any other promise — when the function returns, with the value that is returned — just like a synchronous function</li><li>The promise returned by an <code>async</code> function catches an error using <code>.catch()</code> when the function throws an error</li></ol><p>Let’s say we have a function that returns a promise that resolves after it gets some data from an API. Using promises, this might look like the following:</p><pre>const withPromise = () =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    request(‘<a href="https://google.com%27">https://google.com'</a>)<br/>    .then((data) =&gt; {<br/>      // Pass data to promise resolution<br/>      resolve(data);<br/>    })<br/>    .catch((err) =&gt; {<br/>      // Reject with error<br/>      reject(err);<br/>    });<br/>  });<br/>}</pre><p>Which requires instantiating a new Promise object, then calling .then, .catch, resolve and reject function. Promises require a lot of baggage to get them to work, not to mention a whole set of vocabulary unique to them.</p><p>Using async, we can achieve the same in a few lines</p><pre>const withAsync = async () =&gt; {<br/>  try { return await request(‘<a href="https://google.com%27">https://google.com'</a>) }<br/>  catch (err) { throw err }<br/>}</pre><p>Which not only is concise and reads just like synchronous code, but will return a promise just like the first snippet.</p><pre>withPromise().then(data =&gt; console.log(data));<br/>withAsync().then(data =&gt; console.log(data));</pre><p>(The above snippets use <code>request-promise</code>, a module to make http requests that return promises. They’re also trivial functions that just wrap around the the request method. Also on <a href="https://medium.com/@brett.beekley/how-to-use-async-and-await-to-write-a-function-that-returns-a-promise-60d48d512373">Medium</a>.)</p>
